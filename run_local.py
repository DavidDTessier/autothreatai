#!/usr/bin/env python3
"""
Run all agents locally with ADK.

This script starts all individual agents as A2A servers and the orchestrator,
then optionally starts the main FastAPI application.

Usage:
    uv run python run_local.py
    # or
    ./run_local.py  (if made executable)
"""

import logging
import os
import signal
import subprocess
import sys
import time
from pathlib import Path
from typing import List, Optional

# Add project root to path
project_root = Path(__file__).parent.absolute()
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Agent configuration
AGENTS = [
    {
        "name": "Architecture Parser",
        "dir": "agents/architecture_parser",
        "port": 8001,
        "a2a": True,
    },
    {
        "name": "Threat Modeler",
        "dir": "agents/threat_modeler",
        "port": 8002,
        "a2a": True,
    },
    {
        "name": "Report Content Builder",
        "dir": "agents/report_content_builder",
        "port": 8003,
        "a2a": True,
    },
    {
        "name": "Report Verifier",
        "dir": "agents/report_verifier",
        "port": 8004,
        "a2a": True,
    },
    {
        "name": "Threat Modeler Orchestrator",
        "dir": "agents/orchestrator",
        "port": 8005,
        "a2a": False,
    },
]

# Store process IDs
processes: List[subprocess.Popen] = []


def kill_existing_processes():
    """Kill any existing processes on the agent ports."""
    ports = [str(agent["port"]) for agent in AGENTS] + ["8000"]
    logger.info("Checking for existing processes on ports %s...", ", ".join(ports))
    
    killed_pids = []
    try:
        # Use lsof to find processes on these ports - check each port individually
        for port in ports:
            result = subprocess.run(
                ["lsof", "-ti", f":{port}"],
                capture_output=True,
                text=True,
                check=False
            )
            if result.stdout.strip():
                pids = result.stdout.strip().split("\n")
                for pid in pids:
                    try:
                        pid_int = int(pid.strip())
                        os.kill(pid_int, signal.SIGTERM)
                        killed_pids.append(pid_int)
                        logger.info("Sent SIGTERM to process %s on port %s", pid_int, port)
                    except (ProcessLookupError, ValueError):
                        pass
        
        # Wait for processes to terminate
        if killed_pids:
            logger.info("Waiting for processes to terminate...")
            time.sleep(2)
            
            # Force kill any that are still running
            for pid in killed_pids:
                try:
                    os.kill(pid, 0)  # Check if process exists
                    # Still exists, force kill
                    os.kill(pid, signal.SIGKILL)
                    logger.info("Force killed process %s", pid)
                except (ProcessLookupError, OSError):
                    # Process already terminated
                    pass
            
            time.sleep(1)  # Final wait
    except FileNotFoundError:
        logger.warning("lsof not found, skipping port cleanup")
    except (OSError, subprocess.SubprocessError) as e:
        logger.warning("Error cleaning up ports: %s", e)


def start_agent(agent_config: dict) -> Optional[subprocess.Popen]:
    """Start a single agent as an ADK server."""
    agent_dir = project_root / agent_config["dir"]
    port = agent_config["port"]
    name = agent_config["name"]
    
    if not agent_dir.exists():
        logger.error("Agent directory not found: %s", agent_dir)
        return None
    
    logger.info("Starting %s on port %s...", name, port)
    
    # Build the command using ADK's fast_api to create an app for this single agent
    env = os.environ.copy()
    env["PYTHONPATH"] = str(project_root)
    env["ADK_SUPPRESS_EXPERIMENTAL_FEATURE_WARNINGS"] = "True"
    # Suppress OpenTelemetry warnings about None attribute values
    env["OTEL_SDK_DISABLED"] = "false"  # Keep OTEL enabled but suppress warnings
    
    # Determine the agent name from the directory
    agent_name = agent_dir.name
    
    # Create a wrapper module that uses ADK's fast_api to create a FastAPI app
    # We use uvicorn to run the wrapper module which creates the app
    wrapper_module_content = f'''"""
Temporary wrapper module to start a single ADK agent as a FastAPI app.
This file is auto-generated by run_local.py
"""
import sys
import logging
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

# Suppress OpenTelemetry attribute warnings for None values
logging.getLogger("opentelemetry.attributes").setLevel(logging.ERROR)

from google.adk.cli import fast_api
from starlette.middleware.base import BaseHTTPMiddleware

# Create FastAPI app for the agent
# fast_api.get_fast_api_app expects agents_dir to contain agent subdirectories
# So we pass the parent directory (agents/) and it will discover all agents
# The port parameter controls which port the server runs on
agents_parent = Path(r"{agent_dir.parent}")

app = fast_api.get_fast_api_app(
    agents_dir=str(agents_parent),
    session_service_uri=None,
    artifact_service_uri=None,
    memory_service_uri=None,
    eval_storage_uri=None,
    allow_origins=[],
    web=False,
    trace_to_cloud=False,
    otel_to_cloud=False,
    a2a=True,
    host="0.0.0.0",
    port={port},
    url_prefix=None,
    reload_agents=False,
    extra_plugins=None,
)

# Add A2A middleware if available
try:
    from shared.tools.a2a_utils import a2a_card_middleware
    app.add_middleware(BaseHTTPMiddleware, dispatch=a2a_card_middleware)
except ImportError:
    pass
'''
    
    # Write the wrapper module to a temp file
    wrapper_file = project_root / "app" / f"_agent_wrapper_{agent_name}.py"
    wrapper_file.write_text(wrapper_module_content)
    
    cmd = [
        "uv", "run", "uvicorn",
        f"app._agent_wrapper_{agent_name}:app",
        "--host", "0.0.0.0",
        "--port", str(port)
    ]
    
    try:
        # Start the process - don't capture output so we can see errors in real-time
        # Use a log file for each agent to capture output
        log_file = project_root / "logs" / f"{name.lower().replace(' ', '_')}.log"
        log_file.parent.mkdir(exist_ok=True)
        
        with open(log_file, "w", encoding="utf-8") as f:
            process = subprocess.Popen(
                cmd,
                cwd=str(project_root),  # Run from project root for proper imports
                stdout=f,
                stderr=subprocess.STDOUT,  # Combine stderr with stdout
                env=env
            )
        
        # Check if process started successfully - wait a bit longer for startup
        time.sleep(2)  # Wait for process to start and potentially fail
        if process.poll() is not None:
            # Process exited - likely an error
            logger.error("Failed to start %s. Exit code: %s", name, process.returncode)
            # Read the log file to show the error
            try:
                with open(log_file, "r", encoding="utf-8") as f:
                    error_output = f.read()
                    if error_output:
                        # Show last few lines which usually contain the error
                        lines = error_output.split("\n")
                        error_lines = "\n".join(lines[-10:]) if len(lines) > 10 else error_output
                        logger.error("Error output:\n%s", error_lines)
            except (OSError, IOError):
                pass
            return None
        
        logger.info("%s started with PID %s (logs: %s)", name, process.pid, log_file)
        return process
        
    except (OSError, subprocess.SubprocessError, ValueError) as e:
        logger.error("Failed to start %s: %s", name, e)
        return None


def check_frontend_exists() -> bool:
    """Check if the frontend directory exists."""
    frontend_dir = project_root / "app" / "frontend"
    if not frontend_dir.exists():
        logger.warning("Frontend directory not found: %s", frontend_dir)
        return False
    
    index_file = frontend_dir / "index.html"
    if not index_file.exists():
        logger.warning("Frontend index.html not found: %s", index_file)
        return False
    
    logger.info("Frontend directory found: %s", frontend_dir)
    return True


def start_fastapi_app() -> Optional[subprocess.Popen]:
    """Start the main FastAPI application with frontend."""
    app_dir = project_root / "app"
    server_py = app_dir / "server.py"
    
    if not app_dir.exists():
        logger.error("App directory not found: %s", app_dir)
        return None
    
    if not server_py.exists():
        logger.error("server.py not found: %s", server_py)
        return None
    
    # Check if frontend exists
    frontend_exists = check_frontend_exists()
    if not frontend_exists:
        logger.warning("Frontend not found, but continuing with API server...")
    
    # Check if port is available
    try:
        result = subprocess.run(
            ["lsof", "-ti", ":8000"],
            capture_output=True,
            text=True,
            check=False
        )
        if result.stdout.strip():
            logger.warning("Port 8000 is already in use. Existing process may need to be stopped.")
            # Don't return None - let it try anyway, uvicorn will handle the error
    except Exception:
        pass  # If lsof fails, continue anyway
    
    logger.info("Starting FastAPI application with frontend on port 8000...")
    
    # Set environment variable for orchestrator URL
    env = os.environ.copy()
    env["AGENT_SERVER_URL"] = "http://localhost:8005"
    env["PYTHONPATH"] = str(project_root)
    env["ADK_SUPPRESS_EXPERIMENTAL_FEATURE_WARNINGS"] = "True"
    env["PORT"] = "8000"
    
    try:
        # Start the FastAPI app directly using uvicorn
        cmd = [
            "uv", "run", "uvicorn",
            "app.server:app",
            "--host", "0.0.0.0",
            "--port", "8000",
            "--reload"  # Enable reload for development
        ]
        
        # Use a log file for the FastAPI app
        log_file = project_root / "logs" / "fastapi_app.log"
        log_file.parent.mkdir(exist_ok=True)
        
        with open(log_file, "w", encoding="utf-8") as f:
            process = subprocess.Popen(
                cmd,
                cwd=str(project_root),  # Run from project root for proper imports
                stdout=f,
                stderr=subprocess.STDOUT,  # Combine stderr with stdout
                env=env
            )
        
        # Wait a bit for the process to start
        time.sleep(2)
        if process.poll() is not None:
            # Process exited - likely an error
            logger.error("Failed to start FastAPI app. Exit code: %s", process.returncode)
            # Read the log file to show the error
            try:
                with open(log_file, "r", encoding="utf-8") as f:
                    error_output = f.read()
                    if error_output:
                        lines = error_output.split("\n")
                        error_lines = "\n".join(lines[-20:]) if len(lines) > 20 else error_output
                        logger.error("Error output:\n%s", error_lines)
            except (OSError, IOError):
                pass
            return None
        
        logger.info("FastAPI application (with frontend) started with PID %s (logs: %s)", process.pid, log_file)
        return process
        
    except (OSError, subprocess.SubprocessError, ValueError) as e:
        logger.error("Failed to start FastAPI application: %s", e)
        return None


def check_agent_health(port: int, name: str, max_retries: int = 10) -> bool:
    """Check if an agent is responding on its port."""
    import urllib.error
    import urllib.request
    
    url = f"http://localhost:{port}/health" if port != 8000 else f"http://localhost:{port}/api/health"
    
    for i in range(max_retries):
        try:
            urllib.request.urlopen(url, timeout=1)
            logger.info("%s is healthy", name)
            return True
        except (urllib.error.URLError, ConnectionRefusedError):
            if i < max_retries - 1:
                time.sleep(1)
            else:
                logger.warning("%s health check failed after %s retries", name, max_retries)
                return False
    return False


def check_frontend_health(max_retries: int = 10) -> bool:
    """Check if the frontend is accessible."""
    import urllib.error
    import urllib.request
    
    url = "http://localhost:8000/"
    
    for i in range(max_retries):
        try:
            response = urllib.request.urlopen(url, timeout=2)
            if response.getcode() == 200:
                logger.info("Frontend is accessible")
                return True
        except (urllib.error.URLError, ConnectionRefusedError):
            if i < max_retries - 1:
                time.sleep(1)
            else:
                logger.warning("Frontend health check failed after %s retries", max_retries)
                return False
    return False


def signal_handler(_sig, _frame):
    """Handle shutdown signals."""
    logger.info("\nShutting down all agents...")
    for process in processes:
        try:
            process.terminate()
        except (OSError, ProcessLookupError):
            # Process already terminated or doesn't exist
            pass
    
    # Wait a bit, then force kill if needed
    time.sleep(2)
    for process in processes:
        try:
            process.kill()
        except (OSError, ProcessLookupError):
            # Process already terminated or doesn't exist
            pass
    
    sys.exit(0)


def main():
    """Main function to start all agents."""
    # Set up signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Kill existing processes
    kill_existing_processes()
    
    # Set environment variables for local development
    if not os.getenv("GOOGLE_CLOUD_PROJECT"):
        try:
            result = subprocess.run(
                ["gcloud", "config", "get-value", "project"],
                capture_output=True,
                text=True,
                check=False
            )
            if result.returncode == 0 and result.stdout.strip():
                os.environ["GOOGLE_CLOUD_PROJECT"] = result.stdout.strip()
                logger.info("Set GOOGLE_CLOUD_PROJECT: %s", os.environ["GOOGLE_CLOUD_PROJECT"])
        except FileNotFoundError:
            logger.warning("gcloud CLI not found, skipping GOOGLE_CLOUD_PROJECT setup")
    
    if not os.getenv("GOOGLE_CLOUD_LOCATION"):
        os.environ["GOOGLE_CLOUD_LOCATION"] = "global"
    
    if not os.getenv("GOOGLE_API_KEY") and os.getenv("GOOGLE_GENAI_USE_VERTEXAI") != "True":
        logger.warning("âš ï¸  No GOOGLE_API_KEY or Vertex AI credentials found!")
    
    # Start all agents
    logger.info("=" * 60)
    logger.info("Starting all agents...")
    logger.info("=" * 60)
    
    for agent_config in AGENTS:
        process = start_agent(agent_config)
        if process:
            processes.append(process)
        time.sleep(3)  # Stagger startup with longer delay to avoid quota issues
    
    # Set environment variable for orchestrator agent
    os.environ["AGENT_SERVER_URL"] = "http://localhost:8005"
    
    # Wait for agents to start and stabilize
    logger.info("Waiting for agents to initialize...")
    time.sleep(10)  # Longer wait for agents to fully start and make initial API calls
    
    # Check if sub-agents are running before starting orchestrator/FastAPI
    logger.info("Checking if sub-agents are running...")
    agents_running = 0
    for port in [8001, 8002, 8003, 8004]:
        if check_agent_health(port, f"Agent on port {port}", max_retries=3):
            agents_running += 1
    
    if agents_running < 4:
        logger.warning("Only %d of 4 sub-agents are running. Continuing anyway...", agents_running)
    else:
        logger.info("âœ“ All 4 sub-agents are running")
    
    # Start FastAPI app with frontend
    app_process = start_fastapi_app()
    if app_process:
        processes.append(app_process)
        time.sleep(3)  # Give frontend more time to start
        
        # Check if frontend is accessible
        logger.info("Checking frontend accessibility...")
        check_frontend_health()
    
    # Print status
    logger.info("=" * 60)
    logger.info("All services started!")
    logger.info("=" * 60)
    logger.info("Backend Agents:")
    logger.info("  Architecture Parser:    http://localhost:8001")
    logger.info("  Threat Modeler:          http://localhost:8002")
    logger.info("  Report Content Builder:  http://localhost:8003")
    logger.info("  Report Verifier:         http://localhost:8004")
    logger.info("  Orchestrator:            http://localhost:8005")
    logger.info("")
    logger.info("Frontend & API:")
    logger.info("  ðŸŒ Frontend UI:          http://localhost:8000")
    logger.info("  ðŸ“¡ API Health:            http://localhost:8000/api/health")
    logger.info("")
    logger.info("Press Ctrl+C to stop all services.")
    logger.info("=" * 60)
    
    # Keep running until interrupted
    try:
        while True:
            # Check if any process has died
            for i, process in enumerate(processes):
                if process.poll() is not None:
                    # Process has exited
                    agent_name = AGENTS[i]["name"] if i < len(AGENTS) else "FastAPI App"
                    logger.error("%s (process %s) has exited with code %s", agent_name, i, process.returncode)
                    
                    # Try to read the log file for more details
                    if i < len(AGENTS):
                        log_file = project_root / "logs" / f"{AGENTS[i]['name'].lower().replace(' ', '_')}.log"
                        try:
                            with open(log_file, "r", encoding="utf-8") as f:
                                log_content = f.read()
                                if log_content:
                                    # Show last few error lines
                                    lines = log_content.split("\n")
                                    error_lines = "\n".join([l for l in lines[-5:] if l.strip()])
                                    if error_lines:
                                        logger.error("Last log entries:\n%s", error_lines)
                        except (OSError, IOError):
                            pass
                    
                    # Don't exit immediately - let user see all errors
            time.sleep(5)
    except KeyboardInterrupt:
        signal_handler(None, None)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Interrupted by user")
        signal_handler(None, None)
    except SystemExit:
        raise
    except Exception as e:
        logger.error("Fatal error: %s", e, exc_info=True)
        sys.exit(1)